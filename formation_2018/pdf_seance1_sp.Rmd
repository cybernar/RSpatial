---
title: "Le package sp"
author: "Cyril Bernard (CEFE-CNRS)"
date: "22 janvier 2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Présentation du package sp

## 1.1. sp: Classes and Methods for Spatial Data

Le package sp propose des structures de données pour gérer des données spatiales dans R, un peu à la manière de ce que l'on trouve dans les SIG

- des données ponctuelles, linéaires, surfaciques (= données vectorielles)
- des données matricielles (= données raster) 

C'est le principal package pour la gestion de données vectorielles ! C'est pourquoi beaucoup d'autres packages dépendent de sp (exemples: rgdal, adehabitat, biomod2, maptools). 

Pour les données raster, on utilise plus fréquemment le package ... raster (dont on parlera à la séance 2).

## 1.2. Ce que contient et ne contient pas sp

Les classes proposées par sp permettent de gérer la **partie géométrique** et la **partie attributaire** des données spatiales, ainsi que des métadonnées essentielles telles que le **système de coordonnées** employé dans les données. Il est possible de créer de toutes pièces des entités géographiques avec du code R !

En revanche, sp propose peu de fonctions pour **analyser** les données spatiales : ce sont d'autres packages dépendant de sp qui offrent cela.

Les entrées/sorties depuis ou vers des fichiers SIG (exemple: .shp, .kml, .gpx, .tif, .asc) ne sont gérées par sp. On utilise d'autres packages tel que rgdal ou maptools.

## 1.3. Interactions sp <--> raster

Le package raster est compatible avec le package sp, notamment lorsqu'il faut croiser des données vectorielles et raster.

Exemples : 

- extraire la valeur d'un raster pour N points (```raster::extract```)
- calculer la moyenne, l'écart type, etc. des pixels recouverts par un polygone (```raster::zonal```)

## 1.4. sp, rgeos, sf
Le package **rgeos** a longtemps été, en complément de sp, le seul moyen de faire certains calculs tels que : _zones tampons, intersection, calcul de longueur et de surface_. La logique de rgeos est difficile à appréhender, son efficacité n'est pas optimale.

Heureusement le package **sf** est arrivé ! Il est beaucoup plus rapide et simple d'utilisation. Mais il introduit un nouveau modèle de données différent de sf.

## 1.5. Conclusion

- Pour manipuler des données raster, les commandes de base sont dans le package **raster**
- Pour manipuler des données vectorielles, le package **sf** est simple et efficace
- Le package **sp** reste utilisé en 2018 car ses classes de données spatiales se retrouvent dans d'autres packages tierces ...

## 1.6. Livres, sites

- Bivand R., Pebesma E., Gomez-Rubio V. Applied Spatial Data Analysis 2nd ed. (bibliothèque du CEFE, et voir aussi ASDAR book (<http://www.asdar-book.org/>) 
- Lovelace R., Nowosad J., Muenchow J. Geocomputation with R (<https://geocompr.robinlovelace.net/>)





# 2. TP : les classes de données spatiales dans sp

## 2.1. Les classes Spatial*

- `SpatialPoints` : pour les données spatiales ponctuelles
- `SpatialLines` : pour les données spatiales linéaires
- `SpatialPolygons` : pour les données spatiales surfaciques
- `SpatialPixels` et `SpatialGrid` : pour les données spatiales matricielles ou raster (sur une grille)

## 2.2. Créer un objet SpatialPoints à partir d'une matrice de coordonnées GPS

Définissons un `data.frame` avec 5 lignes et 4 colonnes. Les vecteurs `lon` and `lat` donnent la position GPS des 5 lieux, en degrés décimaux (système de coordonnées WGS84)

```{r 6 lieux dans un data.frame}

fid <- c(1, 2, 3, 4, 5, 6, 7, 8)
name <- c("Montpellier Saint-Roch", "Saint-Aunès", "Villeneuve-lès-Maguelone", 
         "Vic - Mireval", "Baillargues", "Occitanie", "Sabines", "Mosson")
lon <- c(3.88067, 3.9629, 3.84991, 3.79945, 4.00716, 3.84785, 3.86032, 3.81933)
lat <- c(43.60474, 43.63544, 43.54382, 43.50077, 43.65332, 43.63523, 43.58374, 43.61668)
categ <- c("SNCF", "SNCF", "SNCF", "SNCF", "SNCF", "Hérault Transport", 
           "Hérault Transport", "Hérault Transport")
coul <- c("red", "red", "red", "red", "red", "orange", "orange", "orange")
df <- data.frame(fid, name, lon, lat, coul, categ)
```


## 2.3. La classe SpatialPoints

La classe `SpatialPoints` est une structure de données pour stocker des points : seulement la partie "spatiale", pas la partie "attributs".

Pour construire un objet de type `SpatialPoints`, nous avons besoin de :

- une matrice à 2 colonnes (avec des coordonnées X Y, ou "longitude latitude")
- si possible, un objet CRS généré avec la **définition proj 4** du système de coordonnées. Ici la définition vient du site epsg.io : <http://epsg.io/4326>.


```{r Creer un SpatialPoints}
library(sp)
matcoords <- as.matrix(df[,c("lon","lat")])
sp_pts <- SpatialPoints(matcoords, proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs"))
# cette definition proj4stringavec le code EPSG ID est equivalente à la definition complète ...
sp_pts <- SpatialPoints(matcoords, proj4string = CRS("+init=EPSG:4326"))
slotNames(sp_pts)
```

## 2.4. Les classes Spatial*DataFrame

- `SpatialPointsDataFrame` : pour les données spatiales ponctuelles et leurs attributs
- `SpatialLinesDataFrame` : pour les données spatiales linéaires et leurs attributs
- `SpatialPolygonsDataFrame` : pour les données spatiales surfaciques et leurs attributs
- `SpatialPixelsDataFrame` et `SpatialGridDataFrame` : pour des données spatiales matricielles ou raster accompagnées de leur(s) valeur(s)


## 2.5. Créer un 'SpatialPointDataFrame' à partir d'un 'data.frame' muni de coordonnées
Utiliser la fonction coordinates pour créer l'objet, en désignant les 2 colonnes qui contiennent les coordonnées géographiques.
```{r Creer un SpatialPointsDataFrame}
# copier le data.frame
sp_pts_df <- df
# transformer un data.frame en SpatialPointsDataFrame
coordinates(sp_pts_df) <- c("lon","lat")
sp_pts_df
# ceci fonctionne aussi :
sp_pts_df <- df
coordinates(sp_pts_df) <- ~lon+lat
# definir le CRS (optionnel)
proj4string(sp_pts_df) <- CRS("+init=EPSG:4326")
slotNames(sp_pts_df)
```

## 2.6. Relation d'héritage entre les classes Spatial\*, SpatialPoints\* et SpatialPointsDataFrame

Le schema suivant tiré du "ASDAR Book" (<http://www.asdar-book.org/>), p.35 nous montre la composition de la class `SpatialPoints`.

![](media/asdar_p35.png)

---

La classe S4 `Spatial` est la plus générique. Elle a 2 "slots" : bbox (matrix) et proj4string (CRS)

La classe S4 `SpatialPoints` hérite de la classe `Spatial` et l'étend

```{r Classe SpatialPoints, eval=FALSE, include=FALSE}
showClass("SpatialPoints")
showClass("Spatial")
```


## 2.7. SpatialLines et SpatialPolygons 

### Créer des objets SpatialLines et SpatialLinesDataFrame avec R.
Le schema suivant tiré du "ASDAR Book" (<http://www.asdar-book.org/>), p.40 nous montre la composition de la class `SpatialPolygons` et `SpatialLines`

![](media/asdar_p40.png)

Un objet **`SpatialLines`** est composé d'une **liste de `Lines`**.
Un objet **`Lines`** est une **liste of `Line`**.
Un objet **`Line`** est une matrice **matrice de coordonnées** à 2 colonnes, qui représente un ensemble ordonné de points.

**Polygons** = équivalent d'un *MultiPolygone* dans un Shapefile = *MULTIPOLYGON* en notation WKT.
**Lines** = équivalent d'une *MultiPolyligne* dans un Shapefile = *MULTILINESTRING* en notation WKT : <https://en.wikipedia.org/wiki/Well-known_text#Geometric_objects>)



## 2.8. Exemple (1/3): créer 2 polylignes (ensembles de 7 et 5 points)

```{r SpatialLines p1}
# cree 2 objets Lines avec ID slot = L1 and L2
x1 <- c(3.8, 3.8, 3.9, 3.9)
y1 <- c(43.6, 43.5, 43.5, 43.6)
x2 <- c(3.84, 3.84, 3.85, 3.85, 3.86)
y2 <- c(43.75, 43.74, 43.74, 43.73, 43.73)
mat_1 <- cbind(x1, y1)
mat_2 <- cbind(x2, y2)
line_1 <- Line(mat_1)
line_2 <- Line(mat_2)
lines_1 <- Lines(list(line_1), "L1") # L1 est l'identifiant de la polyligne (obligatoire)
lines_2 <- Lines(list(line_2), "L2") # L2 est l'identifiant
```

## 2.9. Exemple (2/3) : SpatialLines 
```{r SpatialLines p2}
sp_lines <- SpatialLines(list(lines_1, lines_2))
plot(sp_lines, axes=T)
str(sp_lines)
```

## 2.10. Exemple (3/3) : SpatialLinesDataFrame
Un objet **`SpatialLines`** résulte de la combinaison entre un **`SpatialLines`** et un **`data.frame`**.
Utiliser le slot **`ID`** du `SpatialLines` et le nom des lignes (**`row.names`**) du `data.frame` pour les mettre en correspondance.
```{r SpatialLines p3}
# créons la table attributaire (data.frame, 2 colonnes)
NAME=c("RANDOM1", "RANDOM2")
LENGTH_M = SpatialLinesLengths(sp_lines, longlat=T) * 1000
df_demo <- data.frame(NAME, LENGTH_M)
row.names(df_demo) <- c("L1","L2")
sp_lines_df <- SpatialLinesDataFrame(sp_lines, df_demo)
sp_lines_df@data
```

## 2.11. Autre exemple: SpatialPolygons (2 entités, 5 et 7 points)

```{r SpatialPolygons p1}
# cree 2 objets Polygons avec ID slot = L1 and L2
x1 <- c(3.8, 3.8, 3.9, 3.9, 3.8)
y1 <- c(43.6, 43.5, 43.5, 43.6, 43.6)
x2 <- c(3.84, 3.84, 3.85, 3.85, 3.86, 3.86, 3.84)
y2 <- c(43.75, 43.74, 43.74, 43.73, 43.73, 43.75, 43.75)
mat_1 <- cbind(x1, y1)
mat_2 <- cbind(x2, y2)
poly_1 <- Polygon(mat_1)
poly_2 <- Polygon(mat_2)
polys_1 <- Polygons(list(poly_1), "P1") # P1 est l'identifiant de la polyligne (obligatoire)
polys_2 <- Polygons(list(poly_2), "P2") # P2 est l'identifiant
```

```{r SpatialPolygons p2, include=FALSE}
sp_polys <- SpatialPolygons(list(polys_1, polys_2))
str(sp_polys)
```

```{r SpatialPolygons p3}
# créons la table attributaire (data.frame, 2 colonnes)
NAME=c("ZONE1", "ZONE2")
df_poly <- data.frame(NAME)
row.names(df_poly) <- c("P1","P2")
sp_polys_df <- SpatialPolygonsDataFrame(sp_polys, df_poly)
sp_polys_df@data
```




# 3. TP: Lecture / écriture shapefile

## 3.1. Répertoire de travail

Nous allons créer un répertoire **data** et télécharger les données nécessaires au TP

```{r Data path}
# afficher le répertoire de destination
getwd()
# créer un sous répertoire
path_data <- "data"
dir.create(path_data)
```

## 3.2. Les données utilisées dans ce TP

* Communes de Montpellier Métropole Méditerranée (Multipolygones)
* Lignes de tramway (Multilignes)
* Arrêts de tramway (Points)

```{r DL DATA}
# changer le répertoire de destination
URL1 <- "http://data.montpellier3m.fr/sites/default/files/ressources/MMM_MMM_Limites.zip"
URL2 <- "http://data.montpellier3m.fr/sites/default/files/ressources/MMM_MMM_LigneTram.zip"
URL3 <- "http://data.montpellier3m.fr/sites/default/files/ressources/MMM_MMM_ArretsTram.zip"
URL4 <- "http://data.montpellier3m.fr/sites/default/files/ressources/MMM_MMM_VeloParc.csv"
download.file(URL1, "data/MMM_MMM_Limites.zip")
download.file(URL2, "data/MMM_MMM_LigneTram.zip")
download.file(URL3, "data/MMM_MMM_ArretsTram.zip")
#download.file(URL4, "data/MMM_MMM_VeloParc.csv")
unzip("data/MMM_MMM_Limites.zip", exdir="data")
unzip("data/MMM_MMM_LigneTram.zip", exdir="data")
unzip("data/MMM_MMM_ArretsTram.zip", exdir="data")
```

## 3.3. Lire / écrire des shapefiles
2 packages sont utilisables

* **rgdal** avec les les fonctions `readOGR` et `writeOGR`
* **maptools** avec les fonctions `readShapePoints`, `readShapeLines`, 
`readShapePoly`, `writeShapePoints`, `writeShapeLines`, `writeShapePoly` 

**rgdal** peut aussi lire les formats ESRI File GDB, PostGIS, MapInfo, GRASS ...

---

### 3.3.1. Paramètres de readOGR / writeOGR pour les shapefiles :
- `dsn` = répertoire du .shp
- `layer` = nom du .shp **sans l'extension**
- `driver` (pour writeOGR) = "ESRI Shapefile"
- `p4s` (optionnel) = définition système coordonnées 
- `overwrite_layer` = FALSE / TRUE 
- `encoding` ("latin1" or "UTF-8")

Remarque : pour la lecture / écriture de données volumineuses, le package sf est nettement plus performant !

## 3.4. Lire un shapefile avec rgdal::readOGR
```{r readOGR exemple}
library(rgdal)
shp_communes  <- readOGR(dsn=path_data,
                         layer="MMM_MMM_Limites")
shp_tramlignes <- readOGR(dsn=path_data,
                          layer="MMM_MMM_LigneTram")
shp_tramarrets <- readOGR(dsn=path_data,
                          layer="MMM_MMM_ArretsTram", 
                          encoding = "UTF-8")
```

---

```{r readOGR SpatialPolygons}
# shp_communes : données attributaires et géométriques
head(shp_communes@data)
plot(shp_communes, axes=T, main="Montpellier Méditerranée Métropole", col="beige")
```


## 3.5. Ecrire un shapefile avec rgdal::writeOGR

L'objet à écrire doit être un Spatial*DataFrame

```{r writeOGR exemple}
writeOGR(sp_lines_df, dsn=path_data, layer="test_lines", 
         driver="ESRI Shapefile", 
         overwrite_layer=TRUE)
writeOGR(sp_pts_df, dsn=path_data, layer="test_points", 
         driver="ESRI Shapefile", 
         overwrite_layer=TRUE)
```

## 3.6. Comment convertir des données spatiales d'un système de coordonnées vers un autre ?

Transformer les coordonnées d'un système vers un autre requiert `rgdal`. Le package `rgdal` ne fournit pas seulement les drivers nécessaires pour lire et écrire les formats de fichier raster et vecteur.

**Le package `rgdal` est aussi nécessaire pour convertir les coordonnées de données spatiales d'un système vers un autre.** La fonction `rgdal::spTransform` s'applique sur tous les objets de classe `Spatial*` et `Spatial*DataFrame`.

---

### 3.6.1. La fonction `spTransform`

Le système de coordonnées de l'objet **origine** doit bien sûr être défini (slot `proj4string`).

Le système de coordonnées de l'objet **destination** est passé en paramètre de `spTransform`

```{r transform CRS WGS84 > L93}
# input SpatialPointsDataFrame : check CRS
proj4string(sp_pts_df)
# transformation vers RGF93 / Lambert93
sp_pts_df_l93 <- spTransform(sp_pts_df, CRS("+init=EPSG:2154"))
sp_pts_df_l93@coords
```

---

### 3.6.2. La fonction `spTransform` : autre exemple

Pour les SpatialLinesDataFrame aussi

```{r transform CRS WGS84 > L93 SpatialLines}
# transformation to RGF93 / Lambert93
proj4string(sp_lines_df) # pas de SCR defini !!
# definir SRC origine
proj4string(sp_lines_df) <- CRS("+init=EPSG:4326")
sp_lines_df_l93 <- spTransform(sp_lines_df, CRS("+init=EPSG:2154"))
```


# 4. TP: Visualiser les données sur une carte
Pour en savoir plus : Bivand, ASDAR Book, chap. 3

## 4.1. plot

Pourquoi ça marche pas ?

```{r plot(SpatialPoints)}
plot(shp_communes, axes=T, main="Montpellier Méditerranée Métropole", col="beige")
plot(sp_lines_df, col="red",add=TRUE)
plot(sp_pts_df, col="blue",add=TRUE)
```

---

### 4.1.1. plot (suite)

Avec `plot`, les systèmes de coordonnées doivent être **homogènes**. 
Ici tout est en Lambert 93 !

```{r plot(SpatialPoints) L93}
plot(shp_communes, axes=T, main="Montpellier Méditerranée Métropole", col="beige")
plot(sp_lines_df_l93, col="red",add=TRUE)
plot(sp_pts_df_l93, col="blue",add=TRUE)
```

## 4.2. leaflet
Avec le package `leaflet`, visualisez facilement vos données sur des cartes web interactives, 
avec un fond de carte OpenStreetMap.
Leaflet est utilisable avec **Shiny** et **RPubs**.
```{r leaflet exemple 1}
library(leaflet)
# cliquer sur les marqueurs pour afficher les popups !
leaflet() %>%
  addTiles() %>%
  addMarkers(data=sp_pts_df, popup=name)
```

RMarkdown users ! installer webshot et phantomJS pour imprimer les cartes leaflet en PDF
https://bookdown.org/yihui/bookdown/html-widgets.html

---

### 4.2.1. leaflet, exemple 2
```{r leaflet exemple 2}
leaflet() %>%
  addTiles() %>%
  addPolylines(data=sp_lines_df, label=paste(NAME,"=",LENGTH_M,"m.")) %>%
  addCircleMarkers(data=sp_pts_df, color=coul)
```

## 4.3. tmap
```{r tmap}
library(tmap)
tm_shape(sp_pts_df) +
  tm_symbols(col="categ") 

tm_shape(shp_communes) +
  tm_polygons() +
tm_shape(sp_pts_df) +
  tm_symbols(size=0.4, 
             col="categ", palette=c(A="blue",B="red"),
             shape=17) 
```

https://www.r-graph-gallery.com/6-graph-parameters-reminder/
http://www.r-graph-gallery.com/42-colors-names/

## 4.4. étendue, barre d'échelle, flèche du nord, labels dans tmap

```{r tmap enhanced}
tm_shape(shp_communes) +
  tm_polygons(col="beige") +
tm_shape(sp_pts_df) +
  tm_symbols(size=0.4, 
             col="categ", palette=c(A="blue",B="red"), title.col="Types de gare",
             shape=17) +
  tm_text("fid", 
          fontface="bold", ymod=1) + 
tm_style(style="white") +
tm_layout(main.title="Gares routières et SNCF dans la métropole de Montpellier",
          main.title.position = c("center","top"), main.title.size = 1,
          legend.title.size = 1, legend.title.fontface = "bold",
          inner.margins = c(0.1, 0.1, 0.1, 0.1)) +
tm_compass(type = "arrow", size=1.5, fontsize=0.6, position = c("right","top")) +
tm_scale_bar(size=0.5, breaks=c(0,5,10)) +
tm_credits("Données : Montpellier 3M, SNCF", position=c("left","bottom"))

```




## 5. Exercice: lignes de tramways

Avec tmap, afficher les 4 lignes de tramway avec une couleur particulière. 
Afficher les communes de la métropole en fond de carte, mais zoomer sur l'étendue des 4 lignes.

```{r tmap tram}
tm_shape(shp_communes, bbox = shp_tramlignes@bbox) +
  tm_polygons() +
tm_shape(shp_tramlignes) +
  tm_lines() +
tm_shape(shp_tramarrets) +
  tm_symbols(size=0.2) +
tm_layout(main.title="Lignes de tramway dans la métropole de Montpellier", 
          main.title.position = c("center","top"), main.title.size = 1.)
```



# 6. COMMENT FAIRE POUR ...

## 6.1. Comment lire des coordonnées en degrés minutes secondes ?
char2dms convertit une chaîne en objet DMS. La chaîne doit se terminer par N,S,W ou E. Préciser le caractère utilisé pour les degrés, les minutes, les secondes (par défaut : d,',"). as.numeric convertit l'objet DMS en degrés décimaux.

```{r DMS 2 DD}
villes <- c("Paris", "Madrid", "Buenos-Aires", "New-York")
char_lat <- c("48°51' 24\" N", "40°26'00\"N", "34°36'29\"S", "40°42' 52\"N")
char_lon <- c("2°21'07\"E", "3°41' W", "58°22' 13\" W", "74°0'22\"W")
dd_lat <- as.numeric(char2dms(char_lat, "°", "'", "\""))
dd_lon <- as.numeric(char2dms(char_lon, "°", "'", "\""))
leaflet() %>% addTiles() %>% addMarkers(lng=dd_lon, lat=dd_lat)
```

## 6.2. Comment calculer une matrice de distance entre des points ?
spDists calcule les distances entre 2 ensembles de points.

Si les coordonnées des points sont dans un système métrique (exemple UTM), alors utiliser longlat=FALSE pour obtenir la distance euclidienne en mètres.

Si les coordonnées des points sont en degrés (exemple WGS84), alors utiliser longlat=TRUE. On obtient une distance en km.

```{r Geodesic dist}
# distance entre Madrid, Buenos Aires, Paris, New-York (cf exemple précédent)
sp_pts_villes <- data.frame(villes, dd_lat, dd_lon, char_lat, char_lon)
coordinates(sp_pts_villes) <- c("dd_lon","dd_lat")
proj4string(sp_pts_villes) <- CRS("+init=EPSG:4326")

# matrice de distance : toutes les combinaisons 
m <- spDists(sp_pts_villes, longlat=TRUE)
dimnames(m) <- list (c("PAR","MAD","BAI","NYC"), c("PAR","MAD","BAI","NYC"))
m
# distances consécutives
v <- spDists(sp_pts_villes, longlat=TRUE, segments=TRUE)
names(v) <- c("PAR-MAD","MAD-BAI", "BAI-NYC")
v
```

## 6.3. Un subset des données spatiales
Pour filtrer les données d'un objet Spatial*DataFrame d'après les valeurs d'une colonne, 
nous procédons de la même manière d'avec un data.frame.

Exemple : filtrez les points de la ligne 4 dans un nouveau SpatialPointsDataFrame

## 6.3. Comment sélectionner les points qui intersectent un polygone ?

Exemple: sélectionnez les arrêts de tramway situés sur la commune de Castelnau-Le-Lez

## Exercice

Sélectionnez les arrêts de tramway en dehors de la commune de Montpellier

Combien y-a-il d'arrêt de tramway dans chaque commune ?

## 6.4. Comment enregistrer vos données en KML pour les visualiser dans Google Earth ?

Créer un fichier KML avec les arrêts de tramways :
- marqueurs bleu pour la ligne 1
- marqueurs orange pour la ligne 2
- marqueurs vert pour la ligne 3
- marqueurs jaune pour la ligne 4

# Conclusion de la séance 1

## Ce que nous avons vu aujourd'hui 

- les structures de données spatiales introduites dans sp :
SpatialPoints, SpatialLines, SpatialPolygons, 
SpatialPointsDataFrame, SpatialLinesDataFrame, SpatialPolygonsDataFrame
- comment lire et écrire des fichiers SIG vectoriel avec rgdal
- gérer le système de coordonnées des données
- présenter les données sur une carte simple

## Ce que nous n'avons pas abordé aujourd'hui

### ... mais que nous verrons avec le package sf
- calcul de surface
- jointures attributaires et spatiales
- zones tampons
- intersecter des données vectorielles (lignes et polygones, polygones et polygones)
- requêtes spatiales complexes
- cartes choroplèthes

